https://stackoverflow.com/questions/21217218/find-and-discard-shared-edges-between-polygons

Computing the convex hull of polygons with shared edges does not work, because by definition the result is a convex polygon. While in your case, the result of merging multiple convex polygons with shared edges may not be convex anymore.

I would propose the following approach (it's not trivial, I don't know whether it can be done in a simpler way):

Change the representation of the polygons to arrays of vertex indices (this simplifies some of the later steps)

Traverse all polygons and append all their vertices to a large array of vertices. While iterating over the vertices of a polygon and appending them to the large array, generate a small array of corresponding vertex indices (the new polygon representation). A polygon is now an array of vertex indices referring to the large array of vertices (used by all the polygons).
Identify shared vertices

Maintain a map from vertex index to counter (a vertex index is the index of a vertex in the large array of vertices created in 1.). This will keep track of how many polygons a vertex belongs to and allow to identify shared vertices.

Traverse all polygons and their vertex indices and for each vertex index you have, insert it in this map or increment the counter if it is already in the map.
Identify shared edges (and keep track of which polygons they belong to)

Maintain a map from (i, j) (with i < j) from pairs of vertex indices to (counter, polygon index1, polygon index2).

The constraint i < j make sure edges with different orientation are not counted twice (this also means when querying the map you have to make sure that i < j in your query pair).
The counter counts the number of polygons an edge belongs to. The problem is in 2D and I assume the data is clean (polygons are not overlapping each other), so the value of this counter should be either 1 or 2.
The polygon index1 and polygon index2 are referring to the indices of polygons the edge may belong to in the array of polygons (these indices can be initialized to -1).
Traverse all the polygons and their edges (iterate over the list of vertex indices without forgetting the final edge closing the loop). For each edge (i, j) with i < j, update the map by either creating the entry in the map, or updating its counter and polygon indices.
Generate the new array of polygons

Iterate over all the polygons from the initial array. For each polygon, a new polygon may be generated:

Find a vertex index in the polygon that is not shared (using the map from 2.). If there is no such vertex index, discard the polygon and move to the next non-discarded polygon.
Output the (non-shared) vertex index. Starting from this vertex index, iterate over all the edges of the polygon:

If the edge is not shared, output the destination vertex index and move to the next edge.
If the edge is shared, you need to find out which polygon it is shared with (to continue iterating over the edges of the new polygon). Use the edge map from 3. to do this. Locate the edge in the other polygon and continue iterating over the edges of this other polygon (in the opposite direction w.r.t. to the shared edge).
This iteration over the edges of the new polygon should eventually loop back to the starting (non-shared) vertex index, which means the new polygon is closed and can be appended to the new array of polygons.
While iterating over the edges of different polygons to generate the final merged polygon, the traversed polygons should be tracked, so that they can be discarded in the outer loop.
Convert the representation of the new polygons back to array of vertices (if needed)

Simply iterate over the new polygons and their array of vertex indices. Fetch the corresponding vertices from the array of vertices created in 1. and append it a new array of vertices for this polygon.